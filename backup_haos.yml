---
- name: Backup HAOS Backups to Network Share
  hosts: server2k19.reisingers.com
  gather_facts: no

  vars:
    # NOTE: These variables are used as direct UNC paths
    source_share: '\\haos01\backup'
    destination_share: '\\kevireis-home\i$\Applications\Haos\Backup'
    share_username: '' # Provide username if needed for authentication
    share_password: '' # Provide password if needed for authentication
    max_backups_to_keep: 10

  tasks:
    - name: Copy HAOS backups via UNC paths and apply retention
      ansible.windows.win_powershell:
        parameters:
          source_share: "{{ source_share }}"
          destination_share: "{{ destination_share }}"
          share_username: "{{ share_username }}"
          share_password: "{{ share_password }}"
          max_backups_to_keep: "{{ max_backups_to_keep }}"
        script: |
          param(
            [string]$source_share,
            [string]$destination_share,
            [string]$share_username,
            [string]$share_password,
            [int]$max_backups_to_keep
          )

          $source_path = $source_share
          $destination_path = $destination_share
          $robocopy_log = "C:\Temp\HAOS_Backup_Copy_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
          $robocopy_exit_code = 0 # Initialize

          Write-Host "=== Starting HAOS backup copy process (UNC Method) ==="

          # --- Step 1: Handle Authentication (If credentials provided) ---
          if (-not [string]::IsNullOrWhiteSpace($share_username)) {
            Write-Host "Authenticating UNC paths using provided credentials..."
            try {
                # This uses net use command *without* a drive letter to authenticate the current session context.
                cmd.exe /c "net use $source_share /user:$share_username $share_password" | Out-Null
                cmd.exe /c "net use $destination_share /user:$share_username $share_password" | Out-Null

                if ($LASTEXITCODE -ne 0) {
                    Write-Host "FATAL ERROR: Failed to authenticate to network share (Net Use Exit Code $LASTEXITCODE). Proceeding to final failure dump."
                    $robocopy_exit_code = 99
                }
            }
            catch {
                Write-Host "FATAL ERROR: Failed to handle network authentication. Proceeding to final failure dump."
                $robocopy_exit_code = 99
            }
          } else {
            Write-Host "No credentials provided. Copying using current WinRM user context."
          }

          # --- Step 2: Copy Files using Robocopy (UNC to UNC) ---
          if ($robocopy_exit_code -eq 0) {
            Write-Host "Executing robocopy from $source_path to $destination_path..."
            
            # /MIR (Mirror), /R:1 /W:3 (retries), /V (verbose), /NP (no progress), /LOG+ (append)
            robocopy $source_path $destination_path /MIR /R:1 /W:3 /V /NP /LOG+:$robocopy_log

            $robocopy_exit_code = $LASTEXITCODE
            Write-Host "Robocopy finished with exit code $robocopy_exit_code."
          }

          # --- Step 3: Apply Retention Policy (Only if Robocopy was successful or minor error) ---
          if ($robocopy_exit_code -le 7) { 
              Write-Host "Applying retention policy (keeping $max_backups_to_keep latest backups) on $destination_path..."
              
              try {
                  $backups = Get-ChildItem -Path $destination_path -Include *.tar, *.tar.gz, *.zip -File -Recurse | Sort-Object LastWriteTime -Descending

                  if ($backups.Count -gt $max_backups_to_keep) {
                    $toDelete = $backups | Select-Object -Skip $max_backups_to_keep
                    foreach ($file in $toDelete) {
                      Write-Host "Deleting old backup: $($file.FullName)"
                      Remove-Item $file.FullName -Force -ErrorAction SilentlyContinue
                    }
                  }
              } catch {
                  Write-Host "WARNING: Failed to apply retention policy."
              }
          }
          
          # --- Step 4: Clean Up Authentication Session ---
          if (-not [string]::IsNullOrWhiteSpace($share_username)) {
            Write-Host "Cleaning up network authentication..."
            cmd.exe /c "net use $source_share /delete" | Out-Null
            cmd.exe /c "net use $destination_share /delete" | Out-Null
          }

          # --- Step 5: FINAL DIAGNOSTIC DUMP (Forcing Failure to See Output) ---
          
          $logContent = Get-Content $robocopy_log -ErrorAction SilentlyContinue | Out-String
          
          # This message includes all the critical status information
          $diagnosticMessage = @"
          --- TASK DIAGNOSTICS DUMP ---
          Status: Robocopy returned code $robocopy_exit_code. 
          If code is 0/1/3, the copy ran but found nothing or skipped existing files.
          If code is 5 (Access Denied) or >7 (Critical Error), the copy failed.
          
          ROBOCOPY LOG CONTENTS:
          $logContent
          --- END ROBOCOPY LOG CONTENTS ---
          "@

          # Use Write-Host for final friendly message (if not failing)
          Write-Host "=== Task processing complete. Review diagnostics below if failure occurred. ==="
          
          # CRITICAL: We are forcing an EXIT 1 to make Ansible/Semaphore output the log/error message.
          if ($robocopy_exit_code -le 7) { # Successful/Minor Error (but files didn't copy)
            Write-Error "ATTENTION: Robocopy finished with non-critical code ($robocopy_exit_code), but files did not copy. \`n\`n$diagnosticMessage"
            exit 1
          } else { # Critical Failure (Access Denied/Fatal)
            Write-Error "CRITICAL FAILURE: Robocopy exited with code $robocopy_exit_code. \`n\`n$diagnosticMessage"
            exit 1
          }
